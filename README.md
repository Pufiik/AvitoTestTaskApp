Добрый день, это мое Android-приложение для реализации музыкального сервиса
При запуске приложения пользователь попадает на экран чарта и поиска треков. Для поиска трека необходимо
ввеси запрос и нажать кнопку поиск. Поиск осуществляется по названию трека и автору.
Для того, чтобы воспроизвести трек, необходимо нажать на трек и приложение автоматически
перекинет пользователя на экран проигрывания трека, где с помощью плейера можно переключаться между
треками. Если выйти из проигрывателя, трек продолжит играть до тех пор, пока не нажмется кнопка паузы.
Также возможна перемотка трека, он будет играть с того момента, где остановится ползунок.
При использовании BottomNavBar осуществляется переход между экранами скачанных треков и
треком из интеренета. 


Прошу обратить внимание на код, на структуру и подход решения.

Для написания приложения я использовала декларативный язык Compose
Для реализации я использовала архитектуру MVI, поделив всю логику на три слоя: data, domain, presentation
Для реализации DI я использовала Koin, все зависимотси приведены в файле TrackRepositoryModule
Постаралась реализовать подход "Чистой архитектуры", максимально сепарировать модули и логику друг от друга
Проигрывание треков реализовала с помощью ExoPlayer
Локальное сохранение треков для реализации скачанных треков реализовала через Shared Preferences 
(подход не самый удачный, хотела реализовать через Room, однако не хватило времени и не произошел конфликт Koin и Database, поэтому выбрала более простой вариант)
Для реализации похода в сеть реализовала через Retrofit2 и Glide. Для реализации
многопоточности использовала корутины (async для параллелизации операций). 
Хочу добавить, что TrackViewModel содержит ссылку на Job и отменяет её в случае запроса,
при неоконченном ответе прошлой корутины. Также есть переключение по Dispatchers и ограничение для
выполнения
Дополнительно использую универсальный класс Result,
для обработки ошибок и получения результатов (класс работает с Generic). Данный класс имеет функции-
расширения для обратоки результа запроса сети как в случае успеха, так и в случае ошибки. 

Возникла сложность с реализацией foreground-сервиса, так как никогда с этим не работала до этого.
Не успела доделать логику DownloadViewModel, хотела использовать SharedViewModel и подменять state для
корректной работы приложения.
